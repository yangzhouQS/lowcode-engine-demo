# React Simulator Renderer 架构设计文档

## 1. 模块概述

### 1.1 模块定位

`@alilc/lowcode-react-simulator-renderer` 是低代码引擎的模拟器渲染器模块，负责在设计器中模拟和渲染低代码组件。它是连接低代码设计器和实际运行时环境的桥梁，提供实时的预览和交互能力。

### 1.2 核心职责

- **组件渲染**: 在模拟器环境中渲染低代码组件和页面
- **实例管理**: 管理组件实例的生命周期和状态
- **路由模拟**: 提供内存路由，支持多页面应用模拟
- **国际化支持**: 提供多语言切换能力
- **设备适配**: 支持不同设备的响应式渲染
- **事件处理**: 处理组件的交互事件
- **DOM 操作**: 提供 DOM 节点查询和操作能力

### 1.3 技术栈

- **React 16**: 基于 React 16 进行组件渲染
- **MobX**: 使用 MobX 进行状态管理和响应式更新
- **React Router**: 使用内存路由进行页面导航模拟
- **TypeScript**: 使用 TypeScript 提供类型安全

## 2. 架构设计

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    SimulatorRendererView                    │
│                      (React Component)                      │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           │ Router
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                         Layout                              │
│                   (布局组件，可选)                          │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           │ Routes
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                         Renderer                            │
│                   (文档渲染组件)                            │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           │ LowCodeRenderer
                           ▼
┌─────────────────────────────────────────────────────────────┐
│              SimulatorRendererContainer                     │
│                   (渲染器容器)                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │           DocumentInstance[]                       │    │
│  │        (文档实例数组，多文档支持)                   │    │
│  └────────────────────────────────────────────────────┘    │
│  ┌────────────────────────────────────────────────────┐    │
│  │           Components Map                            │    │
│  │        (组件映射表，包含内置和用户组件)              │    │
│  └────────────────────────────────────────────────────┘    │
│  ┌────────────────────────────────────────────────────┐    │
│  │           App Context                              │    │
│  │        (应用上下文，包含 utils、i18n 等)            │    │
│  └────────────────────────────────────────────────────┘    │
│  ┌────────────────────────────────────────────────────┐    │
│  │           History (Memory)                         │    │
│  │        (内存路由历史)                              │    │
│  └────────────────────────────────────────────────────┘    │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           │ Host Connection
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                    BuiltinSimulatorHost                     │
│                   (设计器主机，外部注入)                     │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心类设计

#### 2.2.1 SimulatorRendererContainer

**职责**: 渲染器容器，管理整个模拟器的渲染逻辑

**核心属性**:
```typescript
class SimulatorRendererContainer {
  readonly isSimulatorRenderer = true;  // 标识符
  readonly history: MemoryHistory;      // 内存路由
  private _documentInstances: DocumentInstance[];  // 文档实例数组
  private _components: Record<string, React.FC | React.ComponentClass>;  // 组件映射
  private _appContext: any;            // 应用上下文
  private _designMode: string;         // 设计模式
  private _device: string;             // 设备类型
  private _locale: string;             // 语言环境
  private _componentsMap: any;          // 组件元数据映射
  autoRender: boolean;                // 自动渲染标志
  autoRepaintNode: boolean;           // 自动重绘节点标志
}
```

**核心方法**:
- `load(asset: Asset)`: 加载资源
- `getComponent(componentName: string)`: 获取组件
- `createComponent(schema)`: 创建低代码组件
- `run()`: 启动渲染器
- `rerender()`: 刷新渲染器
- `dispose()`: 销毁渲染器

#### 2.2.2 DocumentInstance

**职责**: 文档实例，管理单个文档的渲染状态

**核心属性**:
```typescript
class DocumentInstance {
  instancesMap: Map<string, ReactInstance[]>;  // 实例映射表
  private _components: any;                    // 组件集合
  private _appContext: any;                    // 应用上下文
  private _designMode: string;                 // 设计模式
  private _device: string;                     // 设备类型
  private _componentsMap: any;                 // 组件映射
  readonly container: SimulatorRendererContainer;  // 容器引用
  readonly document: IDocumentModel;           // 文档模型
}
```

**核心方法**:
- `mountInstance(id, instance)`: 挂载组件实例
- `unmountInstance(id, instance)`: 卸载组件实例
- `getNode(id)`: 获取节点
- `mountContext()`: 挂载上下文
- `dispose()`: 销毁实例

#### 2.2.3 SimulatorRendererView

**职责**: React 视图组件，提供渲染器的 UI 层

**核心组件**:
- `SimulatorRendererView`: 根视图组件
- `Layout`: 布局组件（可选）
- `Routes`: 路由组件
- `Renderer`: 文档渲染组件

## 3. 设计模式

### 3.1 观察者模式 (Observer Pattern)

**应用场景**: MobX 响应式状态管理

**实现**:
```typescript
@observer
class Renderer extends Component {
  // 使用 @observer 装饰器，自动订阅 observable 状态变化
  render() {
    // 当 observable 状态变化时自动重新渲染
  }
}
```

**优点**:
- 自动追踪依赖
- 精确更新，避免不必要的渲染
- 代码简洁，减少手动订阅/取消订阅的代码

### 3.2 单例模式 (Singleton Pattern)

**应用场景**: 渲染器容器实例

**实现**:
```typescript
export default new SimulatorRendererContainer();
```

**优点**:
- 全局唯一实例
- 便于跨模块访问
- 统一管理状态

### 3.3 工厂模式 (Factory Pattern)

**应用场景**: 组件创建

**实现**:
```typescript
createComponent(schema: IPublicTypeComponentSchema): Component | null {
  // 根据 schema 创建低代码组件
  class LowCodeComp extends React.Component {
    render() {
      return createElement(LowCodeRenderer, { ... });
    }
  }
  return LowCodeComp;
}
```

**优点**:
- 统一创建逻辑
- 封装创建细节
- 便于扩展和维护

### 3.4 适配器模式 (Adapter Pattern)

**应用场景**: React 实例与低代码节点的适配

**实现**:
```typescript
function getClosestNodeInstance(
  from: ReactInstance,
  specId?: string,
): IPublicTypeNodeInstance<ReactInstance> | null {
  // 将 React 实例适配为低代码节点实例
  return {
    docId,
    nodeId,
    instance: el,
  };
}
```

**优点**:
- 屏蔽底层实现差异
- 提供统一接口
- 便于集成不同框架

### 3.5 策略模式 (Strategy Pattern)

**应用场景**: 设备适配、设计模式切换

**实现**:
```typescript
function getDeviceView(view: any, device: string, mode: string) {
  // 根据设备和模式选择不同的视图策略
  device = ucfirst(device);
  if (device === 'Mobile' && view.hasOwnProperty(device)) {
    view = view[device];
  }
  mode = ucfirst(mode);
  if (mode === 'Preview' && view.hasOwnProperty(mode)) {
    view = view[mode];
  }
  return view;
}
```

**优点**:
- 算法可互换
- 避免条件判断
- 便于扩展新策略

### 3.6 装饰器模式 (Decorator Pattern)

**应用场景**: React 组件功能增强

**实现**:
```typescript
@observer
export class Renderer extends Component {
  // 使用 @observer 装饰器增强组件的响应式能力
}
```

**优点**:
- 动态添加功能
- 不修改原有代码
- 组合多个装饰器

## 4. 数据流设计

### 4.1 状态管理流程

```
Host (设计器主机)
    │
    │ connect() / autorun()
    ▼
SimulatorRendererContainer (Observable State)
    │
    │ @observer
    ▼
SimulatorRendererView (React Component)
    │
    │ props
    ▼
Renderer Component
    │
    │ LowCodeRenderer
    ▼
Component Instances
```

### 4.2 实例管理流程

```
Component Mount
    │
    ▼
onCompGetRef callback
    │
    ▼
documentInstance.mountInstance(id, ref)
    │
    ├─► 检查实例是否已挂载
    ├─► 过滤未挂载的实例
    ├─► 添加新实例到映射表
    └─► 更新 Host 的实例映射
    │
    ▼
host.setInstance(docId, nodeId, instances)
```

### 4.3 路由导航流程

```
用户操作 / Host 事件
    │
    ▼
history.push(path) / history.replace(path)
    │
    ▼
history.listen callback
    │
    ▼
host.project.open(docId)
    │
    ▼
autorun callback
    │
    ▼
更新 _documentInstances
    │
    ▼
Routes Component 重新渲染
    │
    ▼
Renderer Component 渲染新文档
```

## 5. 关键技术实现

### 5.1 React Fiber 遍历

**目的**: 查找 React 组件对应的 DOM 节点

**实现**:
```typescript
function elementsFromFiber(fiber: any, elements: Array<Element | Text>) {
  if (fiber) {
    if (fiber.stateNode && isDOMNode(fiber.stateNode)) {
      elements.push(fiber.stateNode);
    } else if (fiber.child) {
      elementsFromFiber(fiber.child, elements);
    }
    if (fiber.sibling) {
      elementsFromFiber(fiber.sibling, elements);
    }
  }
}
```

**技术点**:
- 深度优先遍历 Fiber 树
- 识别 DOM 节点
- 处理兄弟节点

### 5.2 实例生命周期管理

**目的**: 确保实例正确挂载和卸载

**实现**:
```typescript
mountInstance(id: string, instance: ReactInstance | null) {
  if (instance == null) {
    // 卸载实例
    let instances = this.instancesMap.get(id);
    if (instances) {
      instances = instances.filter(checkInstanceMounted);
      if (instances.length > 0) {
        instancesMap.set(id, instances);
      } else {
        instancesMap.delete(id);
      }
    }
    return;
  }
  
  // 挂载实例
  // 1. 检查实例是否被复用
  // 2. Hook componentWillUnmount
  // 3. 添加实例到映射表
  // 4. 更新 Host
}
```

**技术点**:
- 实例复用检测
- 生命周期钩子劫持
- Symbol 标记节点 ID

### 5.3 内存路由实现

**目的**: 在模拟器中模拟页面导航

**实现**:
```typescript
const history = createMemoryHistory({
  initialEntries: [initialEntry],
});

history.listen((location) => {
  const docId = location.pathname.slice(1);
  docId && host.project.open(docId);
});
```

**技术点**:
- 使用 history 库的 MemoryHistory
- 监听路由变化
- 同步到设计器项目

### 5.4 国际化实现

**目的**: 支持多语言切换

**实现**:
```typescript
export function createIntl(locale: string = 'zh-CN') {
  const intl = (id: string) => {
    return instance[locale]?.[id] || id;
  };
  
  const intlNode = (id: string) => 
    createElement('span', instance[locale]?.[id] || id);
  
  return { intl, intlNode };
}
```

**技术点**:
- 语言包映射
- 回退机制
- React 元素创建

## 6. 性能优化

### 6.1 响应式优化

**策略**: 使用 MobX 的精确响应式

```typescript
@obx.ref private _components: any = {};

@computed get components(): object {
  return this._components;
}
```

**优点**:
- 只在依赖变化时重新计算
- 避免不必要的渲染
- 提高性能

### 6.2 实例缓存

**策略**: 使用 Map 缓存组件实例

```typescript
instancesMap = new Map<string, ReactInstance[]>();
```

**优点**:
- 快速查找实例
- 避免重复创建
- 减少内存占用

### 6.3 条件渲染

**策略**: 根据状态决定是否渲染

```typescript
if (!container.autoRender || isRendererDetached()) {
  return null;
}
```

**优点**:
- 避免不必要的渲染
- 节省计算资源
- 提升响应速度

### 6.4 批量更新

**策略**: 使用 MobX 的 action 批量更新

```typescript
window.addEventListener('beforeunload', () => {
  runInAction(() => {
    (window as any).LCSimulatorHost = null;
    renderer.dispose?.();
    (window as any).SimulatorRenderer = null;
  });
});
```

**优点**:
- 减少通知次数
- 提升性能
- 保证数据一致性

## 7. 扩展性设计

### 7.1 插件机制

**设计**: 通过 Host 注入自定义逻辑

```typescript
host.injectionConsumer.consume((data) => {
  const newCtx = { ...this._appContext };
  merge(newCtx, data.appHelper || {});
  this._appContext = newCtx;
});
```

**优点**:
- 不修改核心代码
- 动态扩展功能
- 便于第三方集成

### 7.2 组件扩展

**设计**: 支持自定义组件和内置组件

```typescript
this._components = {
  ...builtinComponents,
  ...this._components,
};
```

**优点**:
- 灵活组合组件
- 支持组件覆盖
- 便于定制化

### 7.3 主题扩展

**设计**: 通过 CSS 类名控制样式

```typescript
document.documentElement.classList.add('engine-page');
document.body.classList.add('engine-document');
```

**优点**:
- 样式隔离
- 主题切换
- 易于维护

## 8. 安全性设计

### 8.1 实例隔离

**策略**: 使用 Symbol 标记节点

```typescript
const SYMBOL_VNID = Symbol('_LCNodeId');
const SYMBOL_VDID = Symbol('_LCDocId');
```

**优点**:
- 避免属性冲突
- 防止外部访问
- 提升安全性

### 8.2 DOM 操作限制

**策略**: 提供安全的 DOM 操作接口

```typescript
findDOMNodes(instance: ReactInstance): Array<Element | Text> | null {
  return reactFindDOMNodes(instance);
}
```

**优点**:
- 统一接口
- 避免直接操作 DOM
- 便于权限控制

### 8.3 错误处理

**策略**: 提供错误边界和容错机制

```typescript
faultComponent: host.faultComponent,
faultComponentMap: host.faultComponentMap,
```

**优点**:
- 防止页面崩溃
- 提供友好的错误提示
- 便于调试

## 9. 测试策略

### 9.1 单元测试

**覆盖范围**:
- 工具函数
- 组件渲染
- 状态管理

### 9.2 集成测试

**测试场景**:
- 组件挂载/卸载
- 路由导航
- 实例管理

### 9.3 快照测试

**目的**: 确保渲染结果一致性

```typescript
it('should be render NotFoundComponent', () => {
  let tree = component.toJSON();
  expect(tree).toMatchSnapshot();
});
```

## 10. 总结

React Simulator Renderer 模块采用现代化的架构设计，结合了 React、MobX 等成熟技术栈，实现了高性能、高扩展性的低代码模拟器渲染能力。

**核心优势**:
1. **响应式架构**: 基于 MobX 的精确响应式，性能优异
2. **模块化设计**: 清晰的职责划分，易于维护和扩展
3. **类型安全**: TypeScript 提供完整的类型保护
4. **灵活扩展**: 支持插件、组件、主题等多种扩展方式
5. **完善的生命周期**: 完整的实例管理和资源清理机制

**适用场景**:
- 低代码设计器的画布渲染
- 组件预览和调试
- 多页面应用模拟
- 设备适配测试

该模块为低代码引擎提供了强大的渲染能力，是连接设计器和运行时的关键桥梁。
