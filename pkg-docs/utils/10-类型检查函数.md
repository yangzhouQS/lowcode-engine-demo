# 类型检查函数 API 设计文档

## 概述

本文档包含 utils 模块中的所有类型检查函数的 API 设计说明。这些函数用于判断值的类型，提供类型守卫功能。

## 函数列表

### 1. isObject

判断值是否为对象类型。

```typescript
export function isObject(value: any): value is Record<string, any>
```

**参数**:
- `value`: 要判断的值

**返回值**: 如果是对象返回 `true`，否则返回 `false`

**使用示例**:
```typescript
import { isObject } from '@alilc/lowcode-utils';

console.log(isObject({})); // true
console.log(isObject([])); // true（数组也是对象）
console.log(isObject(null)); // false
console.log(isObject(undefined)); // false
console.log(isObject('string')); // false
console.log(isObject(123)); // false
console.log(isObject(true)); // false
```

**实现细节**:
```typescript
export function isObject(value: any): value is Record<string, any> {
  return value !== null && typeof value === 'object';
}
```

**注意**: 数组也是对象类型，所以 `isObject([])` 返回 `true`。

---

### 2. isI18NObject

判断值是否为国际化对象。

```typescript
export function isI18NObject(value: any): boolean
```

**参数**:
- `value`: 要判断的值

**返回值**: 如果是国际化对象返回 `true`，否则返回 `false`

**使用示例**:
```typescript
import { isI18NObject } from '@alilc/lowcode-utils';

console.log(isI18NObject({ type: 'i18n', use: 'zh-CN', 'zh-CN': '你好' })); // true
console.log(isI18NObject({ type: 'string' })); // false
console.log(isI18NObject({})); // false
console.log(isI18NObject(null)); // false
```

**实现细节**:
```typescript
export function isI18NObject(value: any): boolean {
  return isObject(value) && value.type === 'i18n';
}
```

**国际化对象格式**:
```typescript
{
  type: 'i18n',
  use: 'zh-CN',
  'zh-CN': '你好',
  'en-US': 'Hello'
}
```

---

### 3. isFunction

判断值是否为函数类型。

```typescript
export function isFunction(fn: any): boolean
```

**参数**:
- `fn`: 要判断的值

**返回值**: 如果是函数返回 `true`，否则返回 `false`

**使用示例**:
```typescript
import { isFunction } from '@alilc/lowcode-utils';

console.log(isFunction(() => {})); // true
console.log(isFunction(function() {})); // true
console.log(isFunction(async () => {})); // true
console.log(isFunction(function*() {})); // true
console.log(isFunction({})); // false
console.log(isFunction('string')); // false
console.log(isFunction(123)); // false
```

**实现细节**:
```typescript
export function isFunction(fn: any): boolean {
  return typeof fn === 'function';
}
```

---

### 4. getPrototypeOf

获取对象的原型。

```typescript
export function getPrototypeOf(target: any): any
```

**参数**:
- `target`: 目标对象

**返回值**: 对象的原型

**使用示例**:
```typescript
import { getPrototypeOf } from '@alilc/lowcode-utils';

const obj = {};
const proto = getPrototypeOf(obj);
console.log(proto === Object.prototype); // true

const arr = [];
const arrProto = getPrototypeOf(arr);
console.log(arrProto === Array.prototype); // true
```

**实现细节**:
```typescript
export function getPrototypeOf(target: any) {
  if (typeof Object.getPrototypeOf !== 'undefined') {
    return Object.getPrototypeOf(target);
  }

  // eslint-disable-next-line no-proto
  return target.__proto__;
}
```

**兼容性**: 
- 优先使用 `Object.getPrototypeOf`（ES5）
- 降级使用 `__proto__`（非标准，但广泛支持）

---

### 5. setPrototypeOf

设置对象的原型。

```typescript
export function setPrototypeOf(target: any, proto: any): void
```

**参数**:
- `target`: 目标对象
- `proto`: 要设置的原型

**返回值**: 无

**使用示例**:
```typescript
import { setPrototypeOf } from '@alilc/lowcode-utils';

const obj = {};
const proto = { method() { console.log('Hello'); } };

setPrototypeOf(obj, proto);
obj.method(); // 'Hello'
```

**实现细节**:
```typescript
export function setPrototypeOf(target: any, proto: any) {
  if (typeof Object.setPrototypeOf !== 'undefined') {
    Object.setPrototypeOf(target, proto);
  } else {
    // eslint-disable-next-line no-proto
    target.__proto__ = proto;
  }
}
```

**兼容性**: 
- 优先使用 `Object.setPrototypeOf`（ES6）
- 降级使用 `__proto__`（非标准，但广泛支持）

---

### 6. hasOwnProperty

检查对象是否具有指定的自有属性。

```typescript
export function hasOwnProperty(obj: any, key: string | number | symbol): boolean
```

**参数**:
- `obj`: 目标对象
- `key`: 属性键（字符串、数字或符号）

**返回值**: 如果对象具有该自有属性返回 `true`，否则返回 `false`

**使用示例**:
```typescript
import { hasOwnProperty } from '@alilc/lowcode-utils';

const obj = { name: 'Alice', age: 25 };

console.log(hasOwnProperty(obj, 'name')); // true
console.log(hasOwnProperty(obj, 'age')); // true
console.log(hasOwnProperty(obj, 'gender')); // false

// 不会检查原型链上的属性
const proto = { protoMethod() {} };
const child = Object.create(proto);
child.ownMethod = () => {};

console.log(hasOwnProperty(child, 'ownMethod')); // true
console.log(hasOwnProperty(child, 'protoMethod')); // false
```

**实现细节**:
```typescript
const prototypeHasOwnProperty = Object.prototype.hasOwnProperty;
export function hasOwnProperty(obj: any, key: string | number | symbol): boolean {
  return obj && prototypeHasOwnProperty.call(obj, key);
}
```

**优势**: 
- 使用 `call` 方法避免直接调用 `obj.hasOwnProperty` 的问题
- 处理 `obj` 为 `null` 或 `undefined` 的情况
- 避免原型链上的 `hasOwnProperty` 被覆盖的问题

---

## 使用场景

### 1. 类型守卫

```typescript
import { isObject, isFunction } from '@alilc/lowcode-utils';

function processValue(value: any) {
  if (isObject(value)) {
    // TypeScript 知道 value 是 Record<string, any>
    console.log(Object.keys(value));
  }
  
  if (isFunction(value)) {
    // TypeScript 知道 value 是函数
    value();
  }
}
```

### 2. 国际化处理

```typescript
import { isI18NObject, convertToI18NObject } from '@alilc/lowcode-utils';

function processText(text: any) {
  if (isI18NObject(text)) {
    // 处理国际化对象
    return text[text.use];
  }
  
  // 转换为国际化对象
  return convertToI18NObject(text);
}
```

### 3. 原型操作

```typescript
import { getPrototypeOf, setPrototypeOf, hasOwnProperty } from '@alilc/lowcode-utils';

// 创建继承关系
const parent = { parentMethod() {} };
const child = {};

setPrototypeOf(child, parent);
console.log(getPrototypeOf(child) === parent); // true

// 检查自有属性
child.ownMethod = () => {};
console.log(hasOwnProperty(child, 'ownMethod')); // true
console.log(hasOwnProperty(child, 'parentMethod')); // false
```

### 4. 参数验证

```typescript
import { isObject, isFunction } from '@alilc/lowcode-utils';

function validateOptions(options: any) {
  if (!isObject(options)) {
    throw new Error('Options must be an object');
  }
  
  if (!isFunction(options.callback)) {
    throw new Error('Options.callback must be a function');
  }
  
  return options;
}
```

## 最佳实践

1. **使用类型守卫**:
   ```typescript
   // ✅ 推荐: 使用类型守卫
   if (isObject(value)) {
     // TypeScript 知道 value 的类型
     value.property;
   }
   
   // ❌ 不推荐: 使用类型断言
   (value as any).property;
   ```

2. **安全的属性检查**:
   ```typescript
   // ✅ 推荐: 使用 hasOwnProperty
   if (hasOwnProperty(obj, 'key')) {
     console.log(obj.key);
   }
   
   // ❌ 不推荐: 直接访问
   if (obj.key !== undefined) {
     console.log(obj.key);
   }
   ```

3. **原型操作谨慎使用**:
   ```typescript
   // ✅ 推荐: 使用 Object.create
   const child = Object.create(parent);
   
   // ⚠️ 谨慎: 使用 setPrototypeOf
   const child = {};
   setPrototypeOf(child, parent);
   ```

4. **国际化对象处理**:
   ```typescript
   // ✅ 推荐: 先检查再处理
   if (isI18NObject(text)) {
     return text[text.use];
   }
   
   // ❌ 不推荐: 直接访问
   return text[text.use]; // 可能报错
   ```

## 性能考虑

1. **isObject**: O(1)，简单的类型检查
2. **isFunction**: O(1)，简单的类型检查
3. **isI18NObject**: O(1)，两次类型检查
4. **getPrototypeOf**: O(1)，访问原型链
5. **setPrototypeOf**: O(1)，设置原型
6. **hasOwnProperty**: O(1)，检查属性

## 限制和注意事项

1. **isObject**:
   - 数组也是对象，`isObject([])` 返回 `true`
   - `null` 不是对象，`isObject(null)` 返回 `false`
   - 如果需要排除数组，应该使用 `isPlainObject`

2. **isI18NObject**:
   - 只检查 `type` 属性是否为 `'i18n'`
   - 不验证其他属性是否存在
   - 可能误判其他具有相同结构的对象

3. **getPrototypeOf/setPrototypeOf**:
   - 在某些旧浏览器中可能不支持
   - 修改原型可能影响性能
   - 不建议在性能敏感的代码中使用

4. **hasOwnProperty**:
   - 只检查自有属性，不检查原型链
   - 如果需要检查原型链，应该使用 `in` 操作符
   - `key` 可以是 `symbol` 类型

## 相关函数

- [`isPlainObject`](./is-plain-object.ts) - 判断是否为纯对象
- [`isReact`](./is-react.ts) - 判断是否为 React 元素
- [`isElement`](./is-element.ts) - 判断是否为 DOM 元素
- [`convertToI18NObject`](./misc.ts) - 转换为国际化对象

## 使用建议

1. **类型守卫**: 使用类型守卫函数进行类型检查和类型缩小
2. **国际化**: 使用 `isI18NObject` 判断国际化对象，然后进行相应处理
3. **原型操作**: 谨慎使用 `getPrototypeOf` 和 `setPrototypeOf`，优先使用 `Object.create`
4. **属性检查**: 使用 `hasOwnProperty` 检查自有属性，避免原型链问题
5. **参数验证**: 在函数入口处使用类型检查函数验证参数
